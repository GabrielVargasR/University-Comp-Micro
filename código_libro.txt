// =================== TOKENS ===================
typedef enum token_types {
	BEGIN, END, READ, WRITE, ID, INTLITERAL, LPAREN, RPAREN, SEMICOLON, COMMA, ASSIGNOP, PLUSOP, MINUSOP, SCANEOF
} token;

extern token scanner(void);

// =================== Scanner ===================
// TODO Implementar buffer_char(char c)
// TODO Implementar lexical_error(char c)
#include <stdio.h>
#include <ctype.h>

extern char token_buffer[]; 

token scanner(void)
{
	int in_char, c;

	clear_buffer(); // TODO implementar
	if (feof(stdin)) {
		return SCANEOF
	}

	while ((in_char = getchar()) != EOF) {
		if (isspace(in_char)) {
			continue; /* do nothing */
		}
		else if (isalpha(in_char)) {
			/*
			 * ID ::= LETTER | ID LETTER
			 *				 | ID DIGIT
			 *				 | ID UNDERSCORE
			 */
			buffer_char(in_char); // TODO implementar 
			for (c = getchar(); isalnum(c) || c == '_'; c = getchar()) {
				buffer_char(c);
			}
			ungetc(c, stdin); // para no perder el que se acaba de leer que no es alnum
			return check_reserved(); // falta revisar si es reserved o no antes de retornar ID
		} else if (isdigit(in_char)) {
			/*
			 * INTLITERAL ::= DIGIT |
			 *				  INTLITERAL DIGIT
			 */
			buffer_char(c);
			for (c = getchar(); isdigit(c); c = getchar()){
				buffer_char(c);
			}
			ungetc(c, stdin);
			return INTLITERAL;
		} else if (in_char == '(') {
			return LPAREN;
		} else if (in_char == ')') {
			return RPAREN;
		} else if (in_char == ';') {
			return SEMICOLON;
		} else if (in_char == ',') {
			return COMMA;
		} else if (in_char == '+') {
			return PLUSOP;
		} else if (in_char == ':') {
			/*Looking for ':=' */
			c = getchar();
			if (c == '=') {
				return ASSIGNOP;
			} else {
				ungetc(c, stdin);
				lexical_error(in_char);
			}
		} else if (in_char == '-') {
			/* Check for comment or Minusop*/
			c = getchar();
			if (c == '-') {
				do {
					in_char = getchar();
				} while (in_char != '\n');
			} else {
				ungetc(c, stdin); // regresa el char que acaba de leer (que no era '-' a stdin)
				return MINUSOP;
			}
		} else {
			lexical_error(in_char);
		}
	}
}

// =================== CFG ===================
/*
 1. <program> -> begin <statement list> end
 2. <statement list> -> <statement> {<statement>}
 3. <statement> -> ID := <expression>;
 4. <statement> -> read (<id list>);
 5. <statement> -> write (<expr list>);
 6. <id list> -> ID {, ID}
 7. <expr list> -> <expression> {, <expression>}
 8. <expression> -> <primary> {<add op> <primary>}
 9. <primary> -> (<expression>)
10. <primary> -> ID
11. <primary> -> INTLITERAL
12. <add op> -> PLUSOP
13. <add op> -> MINUSOP
14. <system goal> -> <program> SCANEOF
*/

/* Con Action symbols
 1. <program> -> #start begin <statement list> end
 2. <statement list> -> <statement> {<statement>}
 3. <statement> -> <ident> := <expression> #assign;
 4. <statement> -> read (<id list>);
 5. <statement> -> write (<expr list>);
 6. <id list> -> <ident> #read_id {, <ident> #read_id}
 7. <expr list> -> <expression> #write_expr {, <expression> #write_expr}
 8. <expression> -> <primary> {<add op> <primary> #gen_infix}
 9. <primary> -> (<expression>)
10. <primary> -> <ident>
11. <primary> -> INTLITERAL #process_literal
12. <add op> -> PLUSOP #process_op
13. <add op> -> MINUSOP #process_op
14. ID #process_id
15. <system goal> -> <program> SCANEOF #finish
*/

// =================== CFG Impl for Parser ===================
// TODO Implementar match(void)
// TODO Implementar next_token(token tok)
// TODO Implementar syntax_error(token tok)

void system_goal(void)
{
	/* 14. <system goal> -> <program> SCANEOF */
	program();
	match(SCANEOF); // TODO Impl
}

void program(void)
{
	/* 1. <program> -> BEGIN <statement list> END */
	match(BEGIN);
	statement_list();
	match(END);
}

void statement_list(void)
{
	/* 2. <statement list> -> <statement> {<statement>} */
	statement();
	while (TRUE) {
		switch (next_token()) {
			case ID:
			case READ:
			case WRITE:
				statement();
				break;
			default:
				return;
		}
	}
}

void statement(void)
{
	token tok = next_token();

	switch (tok) {
		case ID:
			/* 3. <statement> -> ID := <expression>; */
			match(ID);
			match(ASSIGNOP);
			expression();
			match(SEMICOLON);
			break;
		case READ:
			/* 4. <statement> -> READ (<id list>); */
			match(READ);
			match(LPAREN);
			id_list();
			match(RPAREN);
			match(SEMICOLON);
			break;
		case WRITE:
			/* 5. <statement> -> WRITE (<expr list>); */
			match(WRITE);
			match(LPAREN);
			expr_list();
			match(RPAREN);
			match(SEMICOLON);
			break;
		default:
			syntax_error(tok);
			break;
	}
}

void id_list(void)
{
	/* 6. <id list> -> ID {, ID} */
	match(ID);

	while (next_token() == COMMA) {
		match(COMMA);
		match(ID);
	}
}

void expression(void)
{
	token t;
	/* 8. <expression> -> <primary> {<add op> <primary>} */
	primary();
	for (t = next_token(); t == PLUSOP || t === MINUSOP; t = next_token()) {
		add_op();
		primary();
	}
}

void expr_list(void)
{
	/* 7. <expr list> -> <expression> {, <expression>} */
	while (next_token() == COMMA) {
		match(COMMA);
		expression();
	}
}

void add_op(void)
{
	token tok = next_token();

	/*  */
	if (tok == PLUSOP || tok == MINUSOP){
		match(tok);
	} else {
		syntax_error(tok);
	}
}

void primary(void)
{
	token tok = next_token();

	switch (tok) {
		case LPAREN:
			/* 9. <primary> -> (<expression>) */
			match(LPAREN);
			expression();
			match(RPAREN);
			break;
		case ID:
			/* 10. <primary> -> ID */
			match(ID);
			break;
		case INTLITERAL:
			/* 11. <primary> -> INTLITERAL */
			match(INTLITERAL);
			break;
		default:
			syntax_error(tok);
			break;
	}
}
 

// =================== Semantic Records ===================
#define MAXIDLEN 33
typedef char string[MAXIDLEN];

typedef struct operator {
	enum op {PLUS, MINUS} operator;
} op_rec;

// Expresion types
enum expr { IDEXPR, LITERALEXPR, TEMPEXPR};

// For <primary> and <expression>
typedef struct expression {
	enum expr kind;
	union {
		string name; // for IDEXPR, TEMPEXPR
		int val; // for LITERALEXPR
	}
} expr_rec;

// ============================================================
// =================== Generación de código ===================
// ============================================================

// =================== Action rutines ===================
// TODO Implementar int lookup(string s)
// TODO Implementar void enter(string s)

// check if s is in the symbol table
extern int lookup(string s);

// Put s in the symbol table
extern void enter(string s);

void check_id(string s)
{
	if (! lookup(s)){
		enter(s);
		generate("Declare", s, "Integer", "");
	}
}


char *get_temp(void)
{
	static int max_temp = 0;
	static char tempname[MAXIDLEN];

	mac_temp++;
	sprintf(tempname, "Temp&%d", max_temp);
	check_id(tempname);
	return tempname;
}

void start(void)
{
	// No semantic initializations needed
}

void finish(void)
{
	// Generates the code to finish the program
	generate("Halt", "", "", "");
}

void assign(expr_rec target, expr_rec source)
{
	// Generates the code for assignment
	generate("Store", extract(source), target.name, "");
}

op_rec process_op(void)
{
	// Produce operator descriptor
	op_rec o;

	if (current_token == PLUSOP){
		o.operator = PLUS;
	} else {
		o.operator = MINUS;
	}
	return o;
}

expr_rec gen_infix(expr_rec e1, op_rec op, expr_rec e2)
{
	// Generate code for infix operation
	// Get result temp and set up semantic record for result

	// Sets up temp expression
	expr_rec e_rec;
	e_rec.kind = TEMPEXPR;
	strcpy(e_rec.name, get_temp());

	generate(extract(op), extract(e1), extract(e2), e_rec.name);
	return e_rec;
}


void read_id(expr_rec in_var)
{
	// Generate code for read
	generate("Read", in_var.name, "Integer", "");
}

expr_rec process_id(void)
{
	// Declare ID and build a corresponding semantic record
	expr_rec t;

	check_id(token_buffer);
	t.kind = IDEXPR;
	strcpy(t.name, token_buffer);
	return t;
}

expr_rec process_literal(void)
{
	// Converts literal to a numeric representation
	// and build semantic record

	expr_rec t;
	t.kind = LITERALEXPR;
	/*(void)*/ sscanf(token_buffer, "%d", & t.val); // lee todo el número en el buffer y lo deja en t.val
	return t;
}

void write_expr(expr_rec out_expr)
{
	// Generate code for write
	generate("Write", extract(out_expr), "Integer", "");
}

// =================== Parsing procedure with semantic processing ===================
// TODO adaptar todos los otros parsing procedures
void expression(expr_rec *result)
{
	expr_rec left_operand, right_operand;
	op_rec op;

	primary(& left_operand);
	while (next_token() == PLUSOP || next_token() == MINUSOP) {
		add_op(& op);
		primary(& right_operand);
		left_operand = gen_infix(left_operand, op, right_operand);
	}
	*result = left_operand;
}



/*
TODOs:
- funciones pequeñas:
	Gabriel:
	- buffer_char (scanner)
	- clear_buffer (scanner)
	- check_reserved (scanner) 
	- lexical_error (scanner)
	- match (parser)
	- next_token (parser)
	Kevin:
	- syntax_error (parser)
	- lookup (para symbol table)
	- enter (para symbol table)
	- generate (action rutines)
	- extract (action rutines)
- adaptar funciones del parser (Gabriel)
- adaptar action rutines para generar ARM (Kevin)
- agregar if
- agregar optimización expresión con dos literals

Proceso:
- Se llama a system_goal (del parser)
- El parser pasa llamando al scanner
- El parser va generando código con las action routines conforme llama al scanner
- Cada vez que se llama al scanner, este va recorriendo un poco más el código.
	- Scanner deja literales en token_buffer
- La rutina match es la que llama al scanner para conseguir el siguiente token
- Match guarda el token encontrado en una variable global: current_token
*/
